hue <- c(0, 9, 16, 29, 26, 36, 44, 50, 54, 58, 64, 72, 77, 81, 85, 91)#
    val <- c(1, 1, .8, .7,  1, .4,  1,  1,  1,  1,  1, .7,  1,  1,  1,  1)#
    sat <- c(1, 1, .7,  1,  1,  1,  1,  1,  1,  1, .5,  1,  1, .6,  1,  1)#
    col <- c(hsv(hue / 100, sat, val), "#000000")
plot(seq(1,100), rep(c(1:10,9:2),10)[1:100], pch=as.character(rep(0:9,10)), col=
col, cex=3)
?par
get_colors(3)
par(col=get_colors(3))
palette
.Call.graphics
par(cor="red")
par(col="red")
par(col=c("red", "blue"))
x <- 1:10
x
x[1,3,4]
x[c(1,3,4)]
x[c(2:length(x),1)]
x<- x[c(2:length(x),1)]; x
x<- x[c(2:length(x),1)]; x
x<- x[c(2:length(x),1)]; x
x<- x[c(2:length(x),1)]; x
x<- x[c(2:length(x),1)]; x
x<- x[c(2:length(x),1)]; x
x<- x[c(2:length(x),1)]; x
x<- x[c(2:length(x),1)]; x
x<- x[c(2:length(x),1)]; x
x<- x[c(2:length(x),1)]; x
plot(1,1,col="#0000FF")
plot(1,1,color="#0000FF")
plot(1,1,col="#0000FF")
par(col="black")
plot(1,1,col="#0000FF")
data
data1 <- data[[2]]
# Copyright (c) 2015 by Matthieu Boutier#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy#
# of this software and associated documentation files (the "Software"), to deal#
# in the Software without restriction, including without limitation the rights#
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell#
# copies of the Software, and to permit persons to whom the Software is#
# furnished to do so, subject to the following conditions:#
#
# The above copyright notice and this permission notice shall be included in#
# all copies or substantial portions of the Software.#
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR#
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,#
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE#
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER#
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,#
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN#
# THE SOFTWARE.#
#
exit_usage <- function() {#
    print("usage: --args <file [file]*>")#
    print("usage: --args <directory [directory]>")#
    print("    ... and a lot of other options (see the code).")#
    q()#
}#
#
get_data_ping <- function(csvFile) {#
    csvData <- (read.table(csvFile, header=TRUE, sep="",#
                           colClasses=c("numeric", "numeric", "numeric", "numeric"))#
               )[c("timestamp", "rtt", "ttl", "seq")]#
    names(csvData) <- c("time", "rtt", "ttl", "seq")#
    t0 <- csvData[1,"time"]#
    csvData["time"] <- csvData[,"time"] - t0#
    csvData["ttl"] <- 64 - csvData[,"ttl"]#
#
    maxtime <- max(csvData$time, na.rm = TRUE)#
#
    dat1 <- list(data = csvData[c("time", "rtt")],#
        t0 = t0,#
        type = c("Time", "RTT"),#
        unit = c("s", "ms"),#
        limit = c(maxtime, max(csvData$rtt, na.rm = TRUE)),#
        summary = summary(csvData$rtt))#
#
    dat2 <- list(data = csvData[c("time", "ttl")],#
        t0 = t0,#
        type = c("Time", "Hop number: 64-TTL"),#
        unit = c("s", "hops"),#
        limit = c(maxtime, max(csvData$ttl, na.rm = TRUE)),#
        summary = summary(csvData$ttl))#
#
    # extract packet duplication#
    tmp <- aggregate(csvData["time"], FUN=max, by=list(seq=csvData$seq))["time"]#
    tmp["dup"] <- aggregate(rep(1, nrow(csvData)), FUN=sum,#
        by=list(seq=csvData$seq))$x - 1#
#
    dat3 <- list(data = tmp,#
        t0 = t0,#
        type = c("Time", "Duplicates"),#
        unit = c("s", "count"),#
        limit = c(maxtime, max(tmp$dup, na.rm = TRUE)),#
        summary = summary(tmp$dup))#
    list(dat1, dat2, dat3)#
}#
#
get_data_iperf <- function(csvFile) {#
    csvData <- (read.table(csvFile, sep=",", flush=TRUE,#
                           colClasses=c("character", "character", "numeric",#
                                        "character", "numeric", "numeric",#
                                        "character", "numeric", "numeric"))#
               )[c(1,7,9)]#
    # ignore the last two lines: these are summaries: client and server side.#
    csvData <- csvData[1:(nrow(csvData) - 2),]#
    t0 <- as.numeric(format(strptime(csvData$V1[1], format="%Y%m%d%H%M%S"), "%s"))#
    csvData$V1 <- NULL#
    names(csvData) <- c("time", "bitrate")#
    csvData$time <- as.numeric(sub("-.*", "", csvData$time))#
#
    dat1 <- list(data = csvData,#
        t0 = t0,#
        type = c("Time", "Throughput"),#
        unit = c("s", "bit/s"),#
        limit = c(max(csvData$time, na.rm = TRUE),#
            max(csvData$bitrate, na.rm = TRUE)),#
            summary = summary(csvData$bitrate))#
    list(dat1)#
}#
#
compute_data <- function(csvFile) {#
    extension <- sub(".*[.]", "", csvFile)#
    if(extension == "csv") {#
        get_data_ping(csvFile)#
    } else if (extension == "iperf"){#
        get_data_iperf(csvFile)#
    }#
}#
#
get_colors <- function(number) {#
#plot(seq(1,100), rep(c(1:10,9:2),10)[1:100], pch=as.character(rep(0:9,10)), col=hsv(seq(0,.99,by=.01),1,1), cex=3)#
    hue <- c(0, 9, 16, 29, 26, 36, 44, 50, 54, 58, 64, 72, 77, 81, 85, 91)#
    val <- c(1, 1, .8, .7,  1, .4,  1,  1,  1,  1,  1, .7,  1,  1,  1,  1)#
    sat <- c(1, 1, .7,  1,  1,  1,  1,  1,  1,  1, .5,  1,  1, .6,  1,  1)#
    col <- hsv(hue / 100, sat, val)#
#
    pref <- col[c(1, 2, 3, 4, 7, 8, 10, 12, 14)]#
#
    if (number == 1) {#
        ret <- c("#000000", "#000000")#
    } else if (number <= length(pref)) {#
        tmp <- floor(seq(1:number) * length(pref) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- pref[tmp]#
    } else if (number <= length(col)) {#
        tmp <- floor(seq(1:number) * length(col) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- col[tmp]#
    } else {#
        ret <- c("#000000", col)#
    }#
#   plot(rep(1, 16), pch=20, col = ret, cex = 8)#
    ret#
}#
#
# Draw axis and sub-graduations by hand.#
draw_axis <- function(i, color = "black") {#
    axis_labels = axis(i, col = color)#
    len = length(axis_labels)#
    maxVal = axis_labels[len] * 2#
    by_step = axis_labels[len] - axis_labels[len - 1]#
        axis(i, at = seq(from = 0, to = maxVal, by = by_step),#
             tcl = -.75, col = color)#
    first_digit = as.numeric(substr(as.character(by_step), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = 2#
    } else if (first_digit %% 5 == 0) {#
        div = 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.5 , col = color, labels = FALSE)#
    first_digit = as.numeric(substr(as.character(by_step/div), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = div * 2#
    } else if (first_digit %% 5 == 0) {#
        div = div * 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.25 , col = color, labels = FALSE)#
}#
#
draw_legend <- function(lnames, col, lty, pch) {#
    par(xpd = NA)#
    legend(flag_legend, legend = lnames,#
           col=col,#
           ncol=1, cex = 1,#
           lwd = 1, lty = lty, pch=pch,#
           inset = flag_legend_dec, bg = "white", x.intersp = 1)#
    par(xpd = FALSE)#
}#
#
open_device <- function(filename, type) {#
    filename <- sub(paste(".", type, "$", sep=""), "", filename)#
    filename = paste(filename, type, sep=".");#
    print(paste("drawing:", filename))#
    if(Sys.info()[["sysname"]] == "Darwin") {#
        # On MacOS, the best is to use quartz.#
        quartz(file = filename, width = flag_width,#
               height = flag_height, type = type, dpi=300)#
    } else {#
        # Works on Linux:#
        f_pixels <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height, units = "in", res = 300))#
        }#
        f_other <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height))#
        }#
        tryCatch(f_pixels(), error = function(e) {f_other()})#
    }#
}#
#
normalize <- function(data, min_t0, tmax, max_throughput) {#
    if (max_throughput > 1000000000) {#
        unit <- "Gbit/s"#
        factor <- 1000000000#
    } else if (max_throughput > 1000000) {#
        unit <- "Mbit/s"#
        factor <- 1000000#
    } else if (max_throughput > 1000) {#
        unit <- "Kbit/s"#
        factor <- 1000#
    } else {#
        unit <- "bit/s"#
        factor <- 1#
    }#
    i <- 1#
    while(i <= length(data)) {#
        data[[i]]$data$time <- data[[i]]$data$time + (data[[i]]$t0 - min_t0)#
        data[[i]]$tmax <- tmax#
        if (data[[i]]$unit[2] == "bit/s") {#
            data[[i]]$data$bitrate = data[[i]]$data$bitrate / factor#
            data[[i]]$limit[2] = data[[i]]$limit[2] / factor#
            data[[i]]$unit[2] = unit#
        }#
        i <- i + 1#
    }#
    data#
}#
#
rescale <- function(dat) {#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && flag_maxtime < Inf) {#
            dat$limit[i] = flag_maxtime#
            dat$data <- dat$data[dat$data$time <= flag_maxtime,]#
        } else if (dat$type[i] == "RTT" && flag_maxrtt < Inf) {#
            dat$limit[i] = flag_maxrtt#
        } else if (dat$type[i] == "Duplicates") {#
            # not implemented#
        } else if (dat$type[i] == "Hop number: 64-TTL") {#
            # not implemented#
        } else if (dat$type[i] == "Throughput") {#
            # not implemented#
        }#
    }#
    dat#
}#
#
draw_ecdf <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- sort(dat[,name])#
    n <- length(tmpDat)#
    xmax = data1$limit[2]#
    if (xmax == 0) { xmax = 1 }#
    plot(tmpDat,#
         (1:n) / n,#
         xlim = c(0, xmax), ylim = c(0, 1),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5, lwd = 2,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- color#
    plotdat#
}#
#
draw_normal <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- dat[,name]#
    n <- length(tmpDat)#
    xmax = data1$limit[1]#
    if (xmax == 0) { xmax = 1 }#
    ymax = data1$limit[2]#
    if (ymax == 0) { ymax = 1 }#
    plot(dat$time,#
         tmpDat,#
         xlim = c(0, xmax), ylim = c(0, ymax),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[1], " (", data1$unit[1], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$), 1)]#
    plotdat#
}#
#
reset_plotdat <- function() {#
    list(legend_col = c(), legend_pch = c(), legend_lty = c(),#
        point_type = 0, line_type = 1, color = flag_palette)#
}#
#
new_page <- function(force_separated=FALSE) {#
    if (force_separated || flag_separate_output) {#
        par(mfrow = c(1, 1), mar = c(3,4,1,1) + 0.1, bg = "white")#
    } else {#
        par(mfrow = c(2, 2), mar = c(3,4,1,1) + 0.1, bg = "white")#
    }#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE)#
    par(new = TRUE)#
#
    reset_plotdat()#
}#
#
draw_graph <- function(csvFiles) {#
    data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }#
#
    # normalize data#
    data <- normalize(data, min_t0, tmax, max_throughput)#
#
    # choose the palette#
    if (length(flag_palette == 0) {#
        flag_palette <- get_colors(curve_num))#
    }#
#
    # set output#
    open_device(flag_filename, flag_output_type)#
#
    # Draw ECDF curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, FALSE)#
    }#
#
    plotdat <- reset_plotdat()#
    # Draw all together#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(2)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
    mtext("All together (no scale)", 1, line = 1, las = 0)#
#
    # Draw normal curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, FALSE)#
    }#
#
    # Draw all together#
    plotdat <- reset_plotdat()#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(1)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext("All together (no scale)", 2, line = 1, las = 0)#
    mtext(paste(sep="", data[[1]]$type[1], " (", data[[1]]$unit[1], ")"),#
          1, line = 2, las = 0)#
#
#    draw_legend(legend_names, legend_col, legend_lty, legend_pch)#
#    mtext(document_name, side = 3, line = 2, cex = 2.2, las = 0)#
#
    rc <- dev.off()#
    data#
}#
#
`[.dataclass` <- function(x,i) {#
    class(x) <- "list"#
    structure(x[i], class="dataclass")#
}#
#
`>.dataclass` <- function(e1, e2) {#
    e1[[1]]$type[2] > e2[[1]]$type[2] ||#
    e1[[1]]$summary["3rd Qu."] > e2[[1]]$summary["3rd Qu."]#
}#
#
`==.dataclass` <- function(e1, e2) {#
    e1[[1]]$type[2] == e2[[1]]$type[2] &&#
    e1[[1]]$summary["3rd Qu."] == e2[[1]]$summary["3rd Qu."]#
}#
#
draw_summary <- function(data) {#
    print("Draw summary")#
    class(data) <- "dataclass"#
    data <- sort(data)#
    type <- data[[1]]$type[2]#
#
    # ecdf summaries#
    open_device(paste(names(data[[1]]$data)[2], "-ecdf-summary", sep=""), flag_output_type)#
    palette(get_colors(1))#
    for (dat in data) {#
        if (type != dat$type[2]) {#
                type <- dat$type[2]#
                dev.off()#
            open_device(paste(names(dat$data)[2], "-ecdf-summary", sep=""), flag_output_type)#
            plotdat <- new_page(force_separated = TRUE)#
        }#
        plotdat <- reset_plotdat()#
        plotdat <- draw_ecdf(dat, plotdat, FALSE)#
        mtext(dat$name, side = 3, line = 0, cex = 1, las = 0)#
    }#
    dev.off()#
#
    # standard summaries#
    open_device(paste(names(data[[1]]$data)[2], "-std-summary", sep=""), flag_output_type)#
    palette(get_colors(1))#
    for (dat in data) {#
        if (type != dat$type[2]) {#
                type <- dat$type[2]#
                dev.off()#
            open_device(paste(names(dat$data)[2], "-std-summary", sep=""), flag_output_type)#
            plotdat <- new_page(force_separated = TRUE)#
        }#
        plotdat <- reset_plotdat()#
        plotdat <- draw_normal(dat, plotdat, FALSE)#
        mtext(dat$name, side = 3, line = 0, cex = 1, las = 0)#
    }#
    dev.off()#
}
# Copyright (c) 2015 by Matthieu Boutier#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy#
# of this software and associated documentation files (the "Software"), to deal#
# in the Software without restriction, including without limitation the rights#
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell#
# copies of the Software, and to permit persons to whom the Software is#
# furnished to do so, subject to the following conditions:#
#
# The above copyright notice and this permission notice shall be included in#
# all copies or substantial portions of the Software.#
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR#
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,#
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE#
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER#
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,#
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN#
# THE SOFTWARE.#
#
exit_usage <- function() {#
    print("usage: --args <file [file]*>")#
    print("usage: --args <directory [directory]>")#
    print("    ... and a lot of other options (see the code).")#
    q()#
}#
#
get_data_ping <- function(csvFile) {#
    csvData <- (read.table(csvFile, header=TRUE, sep="",#
                           colClasses=c("numeric", "numeric", "numeric", "numeric"))#
               )[c("timestamp", "rtt", "ttl", "seq")]#
    names(csvData) <- c("time", "rtt", "ttl", "seq")#
    t0 <- csvData[1,"time"]#
    csvData["time"] <- csvData[,"time"] - t0#
    csvData["ttl"] <- 64 - csvData[,"ttl"]#
#
    maxtime <- max(csvData$time, na.rm = TRUE)#
#
    dat1 <- list(data = csvData[c("time", "rtt")],#
        t0 = t0,#
        type = c("Time", "RTT"),#
        unit = c("s", "ms"),#
        limit = c(maxtime, max(csvData$rtt, na.rm = TRUE)),#
        summary = summary(csvData$rtt))#
#
    dat2 <- list(data = csvData[c("time", "ttl")],#
        t0 = t0,#
        type = c("Time", "Hop number: 64-TTL"),#
        unit = c("s", "hops"),#
        limit = c(maxtime, max(csvData$ttl, na.rm = TRUE)),#
        summary = summary(csvData$ttl))#
#
    # extract packet duplication#
    tmp <- aggregate(csvData["time"], FUN=max, by=list(seq=csvData$seq))["time"]#
    tmp["dup"] <- aggregate(rep(1, nrow(csvData)), FUN=sum,#
        by=list(seq=csvData$seq))$x - 1#
#
    dat3 <- list(data = tmp,#
        t0 = t0,#
        type = c("Time", "Duplicates"),#
        unit = c("s", "count"),#
        limit = c(maxtime, max(tmp$dup, na.rm = TRUE)),#
        summary = summary(tmp$dup))#
    list(dat1, dat2, dat3)#
}#
#
get_data_iperf <- function(csvFile) {#
    csvData <- (read.table(csvFile, sep=",", flush=TRUE,#
                           colClasses=c("character", "character", "numeric",#
                                        "character", "numeric", "numeric",#
                                        "character", "numeric", "numeric"))#
               )[c(1,7,9)]#
    # ignore the last two lines: these are summaries: client and server side.#
    csvData <- csvData[1:(nrow(csvData) - 2),]#
    t0 <- as.numeric(format(strptime(csvData$V1[1], format="%Y%m%d%H%M%S"), "%s"))#
    csvData$V1 <- NULL#
    names(csvData) <- c("time", "bitrate")#
    csvData$time <- as.numeric(sub("-.*", "", csvData$time))#
#
    dat1 <- list(data = csvData,#
        t0 = t0,#
        type = c("Time", "Throughput"),#
        unit = c("s", "bit/s"),#
        limit = c(max(csvData$time, na.rm = TRUE),#
            max(csvData$bitrate, na.rm = TRUE)),#
            summary = summary(csvData$bitrate))#
    list(dat1)#
}#
#
compute_data <- function(csvFile) {#
    extension <- sub(".*[.]", "", csvFile)#
    if(extension == "csv") {#
        get_data_ping(csvFile)#
    } else if (extension == "iperf"){#
        get_data_iperf(csvFile)#
    }#
}#
#
get_colors <- function(number) {#
#plot(seq(1,100), rep(c(1:10,9:2),10)[1:100], pch=as.character(rep(0:9,10)), col=hsv(seq(0,.99,by=.01),1,1), cex=3)#
    hue <- c(0, 9, 16, 29, 26, 36, 44, 50, 54, 58, 64, 72, 77, 81, 85, 91)#
    val <- c(1, 1, .8, .7,  1, .4,  1,  1,  1,  1,  1, .7,  1,  1,  1,  1)#
    sat <- c(1, 1, .7,  1,  1,  1,  1,  1,  1,  1, .5,  1,  1, .6,  1,  1)#
    col <- hsv(hue / 100, sat, val)#
#
    pref <- col[c(1, 2, 3, 4, 7, 8, 10, 12, 14)]#
#
    if (number == 1) {#
        ret <- c("#000000", "#000000")#
    } else if (number <= length(pref)) {#
        tmp <- floor(seq(1:number) * length(pref) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- pref[tmp]#
    } else if (number <= length(col)) {#
        tmp <- floor(seq(1:number) * length(col) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- col[tmp]#
    } else {#
        ret <- c("#000000", col)#
    }#
#   plot(rep(1, 16), pch=20, col = ret, cex = 8)#
    ret#
}#
#
# Draw axis and sub-graduations by hand.#
draw_axis <- function(i, color = "black") {#
    axis_labels = axis(i, col = color)#
    len = length(axis_labels)#
    maxVal = axis_labels[len] * 2#
    by_step = axis_labels[len] - axis_labels[len - 1]#
        axis(i, at = seq(from = 0, to = maxVal, by = by_step),#
             tcl = -.75, col = color)#
    first_digit = as.numeric(substr(as.character(by_step), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = 2#
    } else if (first_digit %% 5 == 0) {#
        div = 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.5 , col = color, labels = FALSE)#
    first_digit = as.numeric(substr(as.character(by_step/div), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = div * 2#
    } else if (first_digit %% 5 == 0) {#
        div = div * 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.25 , col = color, labels = FALSE)#
}#
#
draw_legend <- function(lnames, col, lty, pch) {#
    par(xpd = NA)#
    legend(flag_legend, legend = lnames,#
           col=col,#
           ncol=1, cex = 1,#
           lwd = 1, lty = lty, pch=pch,#
           inset = flag_legend_dec, bg = "white", x.intersp = 1)#
    par(xpd = FALSE)#
}#
#
open_device <- function(filename, type) {#
    filename <- sub(paste(".", type, "$", sep=""), "", filename)#
    filename = paste(filename, type, sep=".");#
    print(paste("drawing:", filename))#
    if(Sys.info()[["sysname"]] == "Darwin") {#
        # On MacOS, the best is to use quartz.#
        quartz(file = filename, width = flag_width,#
               height = flag_height, type = type, dpi=300)#
    } else {#
        # Works on Linux:#
        f_pixels <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height, units = "in", res = 300))#
        }#
        f_other <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height))#
        }#
        tryCatch(f_pixels(), error = function(e) {f_other()})#
    }#
}#
#
normalize <- function(data, min_t0, tmax, max_throughput) {#
    if (max_throughput > 1000000000) {#
        unit <- "Gbit/s"#
        factor <- 1000000000#
    } else if (max_throughput > 1000000) {#
        unit <- "Mbit/s"#
        factor <- 1000000#
    } else if (max_throughput > 1000) {#
        unit <- "Kbit/s"#
        factor <- 1000#
    } else {#
        unit <- "bit/s"#
        factor <- 1#
    }#
    i <- 1#
    while(i <= length(data)) {#
        data[[i]]$data$time <- data[[i]]$data$time + (data[[i]]$t0 - min_t0)#
        data[[i]]$tmax <- tmax#
        if (data[[i]]$unit[2] == "bit/s") {#
            data[[i]]$data$bitrate = data[[i]]$data$bitrate / factor#
            data[[i]]$limit[2] = data[[i]]$limit[2] / factor#
            data[[i]]$unit[2] = unit#
        }#
        i <- i + 1#
    }#
    data#
}#
#
rescale <- function(dat) {#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && flag_maxtime < Inf) {#
            dat$limit[i] = flag_maxtime#
            dat$data <- dat$data[dat$data$time <= flag_maxtime,]#
        } else if (dat$type[i] == "RTT" && flag_maxrtt < Inf) {#
            dat$limit[i] = flag_maxrtt#
        } else if (dat$type[i] == "Duplicates") {#
            # not implemented#
        } else if (dat$type[i] == "Hop number: 64-TTL") {#
            # not implemented#
        } else if (dat$type[i] == "Throughput") {#
            # not implemented#
        }#
    }#
    dat#
}#
#
draw_ecdf <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- sort(dat[,name])#
    n <- length(tmpDat)#
    xmax = data1$limit[2]#
    if (xmax == 0) { xmax = 1 }#
    plot(tmpDat,#
         (1:n) / n,#
         xlim = c(0, xmax), ylim = c(0, 1),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5, lwd = 2,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- color#
    plotdat#
}#
#
draw_normal <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- dat[,name]#
    n <- length(tmpDat)#
    xmax = data1$limit[1]#
    if (xmax == 0) { xmax = 1 }#
    ymax = data1$limit[2]#
    if (ymax == 0) { ymax = 1 }#
    plot(dat$time,#
         tmpDat,#
         xlim = c(0, xmax), ylim = c(0, ymax),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[1], " (", data1$unit[1], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$), 1)]#
    plotdat#
}
# Copyright (c) 2015 by Matthieu Boutier#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy#
# of this software and associated documentation files (the "Software"), to deal#
# in the Software without restriction, including without limitation the rights#
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell#
# copies of the Software, and to permit persons to whom the Software is#
# furnished to do so, subject to the following conditions:#
#
# The above copyright notice and this permission notice shall be included in#
# all copies or substantial portions of the Software.#
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR#
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,#
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE#
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER#
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,#
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN#
# THE SOFTWARE.#
#
exit_usage <- function() {#
    print("usage: --args <file [file]*>")#
    print("usage: --args <directory [directory]>")#
    print("    ... and a lot of other options (see the code).")#
    q()#
}#
#
get_data_ping <- function(csvFile) {#
    csvData <- (read.table(csvFile, header=TRUE, sep="",#
                           colClasses=c("numeric", "numeric", "numeric", "numeric"))#
               )[c("timestamp", "rtt", "ttl", "seq")]#
    names(csvData) <- c("time", "rtt", "ttl", "seq")#
    t0 <- csvData[1,"time"]#
    csvData["time"] <- csvData[,"time"] - t0#
    csvData["ttl"] <- 64 - csvData[,"ttl"]#
#
    maxtime <- max(csvData$time, na.rm = TRUE)#
#
    dat1 <- list(data = csvData[c("time", "rtt")],#
        t0 = t0,#
        type = c("Time", "RTT"),#
        unit = c("s", "ms"),#
        limit = c(maxtime, max(csvData$rtt, na.rm = TRUE)),#
        summary = summary(csvData$rtt))#
#
    dat2 <- list(data = csvData[c("time", "ttl")],#
        t0 = t0,#
        type = c("Time", "Hop number: 64-TTL"),#
        unit = c("s", "hops"),#
        limit = c(maxtime, max(csvData$ttl, na.rm = TRUE)),#
        summary = summary(csvData$ttl))#
#
    # extract packet duplication#
    tmp <- aggregate(csvData["time"], FUN=max, by=list(seq=csvData$seq))["time"]#
    tmp["dup"] <- aggregate(rep(1, nrow(csvData)), FUN=sum,#
        by=list(seq=csvData$seq))$x - 1#
#
    dat3 <- list(data = tmp,#
        t0 = t0,#
        type = c("Time", "Duplicates"),#
        unit = c("s", "count"),#
        limit = c(maxtime, max(tmp$dup, na.rm = TRUE)),#
        summary = summary(tmp$dup))#
    list(dat1, dat2, dat3)#
}
get_data_iperf <- function(csvFile) {#
    csvData <- (read.table(csvFile, sep=",", flush=TRUE,#
                           colClasses=c("character", "character", "numeric",#
                                        "character", "numeric", "numeric",#
                                        "character", "numeric", "numeric"))#
               )[c(1,7,9)]#
    # ignore the last two lines: these are summaries: client and server side.#
    csvData <- csvData[1:(nrow(csvData) - 2),]#
    t0 <- as.numeric(format(strptime(csvData$V1[1], format="%Y%m%d%H%M%S"), "%s"))#
    csvData$V1 <- NULL#
    names(csvData) <- c("time", "bitrate")#
    csvData$time <- as.numeric(sub("-.*", "", csvData$time))#
#
    dat1 <- list(data = csvData,#
        t0 = t0,#
        type = c("Time", "Throughput"),#
        unit = c("s", "bit/s"),#
        limit = c(max(csvData$time, na.rm = TRUE),#
            max(csvData$bitrate, na.rm = TRUE)),#
            summary = summary(csvData$bitrate))#
    list(dat1)#
}#
#
compute_data <- function(csvFile) {#
    extension <- sub(".*[.]", "", csvFile)#
    if(extension == "csv") {#
        get_data_ping(csvFile)#
    } else if (extension == "iperf"){#
        get_data_iperf(csvFile)#
    }#
}
get_colors <- function(number) {#
#plot(seq(1,100), rep(c(1:10,9:2),10)[1:100], pch=as.character(rep(0:9,10)), col=hsv(seq(0,.99,by=.01),1,1), cex=3)#
    hue <- c(0, 9, 16, 29, 26, 36, 44, 50, 54, 58, 64, 72, 77, 81, 85, 91)#
    val <- c(1, 1, .8, .7,  1, .4,  1,  1,  1,  1,  1, .7,  1,  1,  1,  1)#
    sat <- c(1, 1, .7,  1,  1,  1,  1,  1,  1,  1, .5,  1,  1, .6,  1,  1)#
    col <- hsv(hue / 100, sat, val)#
#
    pref <- col[c(1, 2, 3, 4, 7, 8, 10, 12, 14)]#
#
    if (number == 1) {#
        ret <- c("#000000", "#000000")#
    } else if (number <= length(pref)) {#
        tmp <- floor(seq(1:number) * length(pref) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- pref[tmp]#
    } else if (number <= length(col)) {#
        tmp <- floor(seq(1:number) * length(col) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- col[tmp]#
    } else {#
        ret <- c("#000000", col)#
    }#
#   plot(rep(1, 16), pch=20, col = ret, cex = 8)#
    ret#
}
draw_axis <- function(i, color = "black") {#
    axis_labels = axis(i, col = color)#
    len = length(axis_labels)#
    maxVal = axis_labels[len] * 2#
    by_step = axis_labels[len] - axis_labels[len - 1]#
        axis(i, at = seq(from = 0, to = maxVal, by = by_step),#
             tcl = -.75, col = color)#
    first_digit = as.numeric(substr(as.character(by_step), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = 2#
    } else if (first_digit %% 5 == 0) {#
        div = 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.5 , col = color, labels = FALSE)#
    first_digit = as.numeric(substr(as.character(by_step/div), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = div * 2#
    } else if (first_digit %% 5 == 0) {#
        div = div * 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.25 , col = color, labels = FALSE)#
}#
#
draw_legend <- function(lnames, col, lty, pch) {#
    par(xpd = NA)#
    legend(flag_legend, legend = lnames,#
           col=col,#
           ncol=1, cex = 1,#
           lwd = 1, lty = lty, pch=pch,#
           inset = flag_legend_dec, bg = "white", x.intersp = 1)#
    par(xpd = FALSE)#
}#
#
open_device <- function(filename, type) {#
    filename <- sub(paste(".", type, "$", sep=""), "", filename)#
    filename = paste(filename, type, sep=".");#
    print(paste("drawing:", filename))#
    if(Sys.info()[["sysname"]] == "Darwin") {#
        # On MacOS, the best is to use quartz.#
        quartz(file = filename, width = flag_width,#
               height = flag_height, type = type, dpi=300)#
    } else {#
        # Works on Linux:#
        f_pixels <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height, units = "in", res = 300))#
        }#
        f_other <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height))#
        }#
        tryCatch(f_pixels(), error = function(e) {f_other()})#
    }#
}#
#
normalize <- function(data, min_t0, tmax, max_throughput) {#
    if (max_throughput > 1000000000) {#
        unit <- "Gbit/s"#
        factor <- 1000000000#
    } else if (max_throughput > 1000000) {#
        unit <- "Mbit/s"#
        factor <- 1000000#
    } else if (max_throughput > 1000) {#
        unit <- "Kbit/s"#
        factor <- 1000#
    } else {#
        unit <- "bit/s"#
        factor <- 1#
    }#
    i <- 1#
    while(i <= length(data)) {#
        data[[i]]$data$time <- data[[i]]$data$time + (data[[i]]$t0 - min_t0)#
        data[[i]]$tmax <- tmax#
        if (data[[i]]$unit[2] == "bit/s") {#
            data[[i]]$data$bitrate = data[[i]]$data$bitrate / factor#
            data[[i]]$limit[2] = data[[i]]$limit[2] / factor#
            data[[i]]$unit[2] = unit#
        }#
        i <- i + 1#
    }#
    data#
}#
#
rescale <- function(dat) {#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && flag_maxtime < Inf) {#
            dat$limit[i] = flag_maxtime#
            dat$data <- dat$data[dat$data$time <= flag_maxtime,]#
        } else if (dat$type[i] == "RTT" && flag_maxrtt < Inf) {#
            dat$limit[i] = flag_maxrtt#
        } else if (dat$type[i] == "Duplicates") {#
            # not implemented#
        } else if (dat$type[i] == "Hop number: 64-TTL") {#
            # not implemented#
        } else if (dat$type[i] == "Throughput") {#
            # not implemented#
        }#
    }#
    dat#
}
draw_ecdf <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- sort(dat[,name])#
    n <- length(tmpDat)#
    xmax = data1$limit[2]#
    if (xmax == 0) { xmax = 1 }#
    plot(tmpDat,#
         (1:n) / n,#
         xlim = c(0, xmax), ylim = c(0, 1),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5, lwd = 2,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- color#
    plotdat#
}
draw_normal <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- dat[,name]#
    n <- length(tmpDat)#
    xmax = data1$limit[1]#
    if (xmax == 0) { xmax = 1 }#
    ymax = data1$limit[2]#
    if (ymax == 0) { ymax = 1 }#
    plot(dat$time,#
         tmpDat,#
         xlim = c(0, xmax), ylim = c(0, ymax),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[1], " (", data1$unit[1], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$), 1)]#
    plotdat#
}
draw_normal <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- dat[,name]#
    n <- length(tmpDat)#
    xmax = data1$limit[1]#
    if (xmax == 0) { xmax = 1 }#
    ymax = data1$limit[2]#
    if (ymax == 0) { ymax = 1 }
plot(dat$time,#
         tmpDat,#
         xlim = c(0, xmax), ylim = c(0, ymax),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)
plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1
if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[1], " (", data1$unit[1], ")"),#
              1, line = 2, las = 0)#
    }
plotdat$point_type <- point_type#
    plotdat$line_type <- line_type
plotdat$color <- plotdat$color[c(2:length(plotdat$), 1)]
plotdat$color <- plotdat$color[c(2:length(plotdat$color), 1)]
plotdat
}
# Copyright (c) 2015 by Matthieu Boutier#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy#
# of this software and associated documentation files (the "Software"), to deal#
# in the Software without restriction, including without limitation the rights#
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell#
# copies of the Software, and to permit persons to whom the Software is#
# furnished to do so, subject to the following conditions:#
#
# The above copyright notice and this permission notice shall be included in#
# all copies or substantial portions of the Software.#
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR#
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,#
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE#
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER#
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,#
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN#
# THE SOFTWARE.#
#
exit_usage <- function() {#
    print("usage: --args <file [file]*>")#
    print("usage: --args <directory [directory]>")#
    print("    ... and a lot of other options (see the code).")#
    q()#
}#
#
get_data_ping <- function(csvFile) {#
    csvData <- (read.table(csvFile, header=TRUE, sep="",#
                           colClasses=c("numeric", "numeric", "numeric", "numeric"))#
               )[c("timestamp", "rtt", "ttl", "seq")]#
    names(csvData) <- c("time", "rtt", "ttl", "seq")#
    t0 <- csvData[1,"time"]#
    csvData["time"] <- csvData[,"time"] - t0#
    csvData["ttl"] <- 64 - csvData[,"ttl"]#
#
    maxtime <- max(csvData$time, na.rm = TRUE)#
#
    dat1 <- list(data = csvData[c("time", "rtt")],#
        t0 = t0,#
        type = c("Time", "RTT"),#
        unit = c("s", "ms"),#
        limit = c(maxtime, max(csvData$rtt, na.rm = TRUE)),#
        summary = summary(csvData$rtt))#
#
    dat2 <- list(data = csvData[c("time", "ttl")],#
        t0 = t0,#
        type = c("Time", "Hop number: 64-TTL"),#
        unit = c("s", "hops"),#
        limit = c(maxtime, max(csvData$ttl, na.rm = TRUE)),#
        summary = summary(csvData$ttl))#
#
    # extract packet duplication#
    tmp <- aggregate(csvData["time"], FUN=max, by=list(seq=csvData$seq))["time"]#
    tmp["dup"] <- aggregate(rep(1, nrow(csvData)), FUN=sum,#
        by=list(seq=csvData$seq))$x - 1#
#
    dat3 <- list(data = tmp,#
        t0 = t0,#
        type = c("Time", "Duplicates"),#
        unit = c("s", "count"),#
        limit = c(maxtime, max(tmp$dup, na.rm = TRUE)),#
        summary = summary(tmp$dup))#
    list(dat1, dat2, dat3)#
}#
#
get_data_iperf <- function(csvFile) {#
    csvData <- (read.table(csvFile, sep=",", flush=TRUE,#
                           colClasses=c("character", "character", "numeric",#
                                        "character", "numeric", "numeric",#
                                        "character", "numeric", "numeric"))#
               )[c(1,7,9)]#
    # ignore the last two lines: these are summaries: client and server side.#
    csvData <- csvData[1:(nrow(csvData) - 2),]#
    t0 <- as.numeric(format(strptime(csvData$V1[1], format="%Y%m%d%H%M%S"), "%s"))#
    csvData$V1 <- NULL#
    names(csvData) <- c("time", "bitrate")#
    csvData$time <- as.numeric(sub("-.*", "", csvData$time))#
#
    dat1 <- list(data = csvData,#
        t0 = t0,#
        type = c("Time", "Throughput"),#
        unit = c("s", "bit/s"),#
        limit = c(max(csvData$time, na.rm = TRUE),#
            max(csvData$bitrate, na.rm = TRUE)),#
            summary = summary(csvData$bitrate))#
    list(dat1)#
}#
#
compute_data <- function(csvFile) {#
    extension <- sub(".*[.]", "", csvFile)#
    if(extension == "csv") {#
        get_data_ping(csvFile)#
    } else if (extension == "iperf"){#
        get_data_iperf(csvFile)#
    }#
}#
#
get_colors <- function(number) {#
#plot(seq(1,100), rep(c(1:10,9:2),10)[1:100], pch=as.character(rep(0:9,10)), col=hsv(seq(0,.99,by=.01),1,1), cex=3)#
    hue <- c(0, 9, 16, 29, 26, 36, 44, 50, 54, 58, 64, 72, 77, 81, 85, 91)#
    val <- c(1, 1, .8, .7,  1, .4,  1,  1,  1,  1,  1, .7,  1,  1,  1,  1)#
    sat <- c(1, 1, .7,  1,  1,  1,  1,  1,  1,  1, .5,  1,  1, .6,  1,  1)#
    col <- hsv(hue / 100, sat, val)#
#
    pref <- col[c(1, 2, 3, 4, 7, 8, 10, 12, 14)]#
#
    if (number == 1) {#
        ret <- c("#000000", "#000000")#
    } else if (number <= length(pref)) {#
        tmp <- floor(seq(1:number) * length(pref) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- pref[tmp]#
    } else if (number <= length(col)) {#
        tmp <- floor(seq(1:number) * length(col) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- col[tmp]#
    } else {#
        ret <- c("#000000", col)#
    }#
#   plot(rep(1, 16), pch=20, col = ret, cex = 8)#
    ret#
}#
#
# Draw axis and sub-graduations by hand.#
draw_axis <- function(i, color = "black") {#
    axis_labels = axis(i, col = color)#
    len = length(axis_labels)#
    maxVal = axis_labels[len] * 2#
    by_step = axis_labels[len] - axis_labels[len - 1]#
        axis(i, at = seq(from = 0, to = maxVal, by = by_step),#
             tcl = -.75, col = color)#
    first_digit = as.numeric(substr(as.character(by_step), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = 2#
    } else if (first_digit %% 5 == 0) {#
        div = 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.5 , col = color, labels = FALSE)#
    first_digit = as.numeric(substr(as.character(by_step/div), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = div * 2#
    } else if (first_digit %% 5 == 0) {#
        div = div * 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.25 , col = color, labels = FALSE)#
}#
#
draw_legend <- function(lnames, col, lty, pch) {#
    par(xpd = NA)#
    legend(flag_legend, legend = lnames,#
           col=col,#
           ncol=1, cex = 1,#
           lwd = 1, lty = lty, pch=pch,#
           inset = flag_legend_dec, bg = "white", x.intersp = 1)#
    par(xpd = FALSE)#
}#
#
open_device <- function(filename, type) {#
    filename <- sub(paste(".", type, "$", sep=""), "", filename)#
    filename = paste(filename, type, sep=".");#
    print(paste("drawing:", filename))#
    if(Sys.info()[["sysname"]] == "Darwin") {#
        # On MacOS, the best is to use quartz.#
        quartz(file = filename, width = flag_width,#
               height = flag_height, type = type, dpi=300)#
    } else {#
        # Works on Linux:#
        f_pixels <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height, units = "in", res = 300))#
        }#
        f_other <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height))#
        }#
        tryCatch(f_pixels(), error = function(e) {f_other()})#
    }#
}#
#
normalize <- function(data, min_t0, tmax, max_throughput) {#
    if (max_throughput > 1000000000) {#
        unit <- "Gbit/s"#
        factor <- 1000000000#
    } else if (max_throughput > 1000000) {#
        unit <- "Mbit/s"#
        factor <- 1000000#
    } else if (max_throughput > 1000) {#
        unit <- "Kbit/s"#
        factor <- 1000#
    } else {#
        unit <- "bit/s"#
        factor <- 1#
    }#
    i <- 1#
    while(i <= length(data)) {#
        data[[i]]$data$time <- data[[i]]$data$time + (data[[i]]$t0 - min_t0)#
        data[[i]]$tmax <- tmax#
        if (data[[i]]$unit[2] == "bit/s") {#
            data[[i]]$data$bitrate = data[[i]]$data$bitrate / factor#
            data[[i]]$limit[2] = data[[i]]$limit[2] / factor#
            data[[i]]$unit[2] = unit#
        }#
        i <- i + 1#
    }#
    data#
}#
#
rescale <- function(dat) {#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && flag_maxtime < Inf) {#
            dat$limit[i] = flag_maxtime#
            dat$data <- dat$data[dat$data$time <= flag_maxtime,]#
        } else if (dat$type[i] == "RTT" && flag_maxrtt < Inf) {#
            dat$limit[i] = flag_maxrtt#
        } else if (dat$type[i] == "Duplicates") {#
            # not implemented#
        } else if (dat$type[i] == "Hop number: 64-TTL") {#
            # not implemented#
        } else if (dat$type[i] == "Throughput") {#
            # not implemented#
        }#
    }#
    dat#
}#
#
draw_ecdf <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- sort(dat[,name])#
    n <- length(tmpDat)#
    xmax = data1$limit[2]#
    if (xmax == 0) { xmax = 1 }#
    plot(tmpDat,#
         (1:n) / n,#
         xlim = c(0, xmax), ylim = c(0, 1),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5, lwd = 2,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$color), 1)]#
    plotdat#
}#
#
draw_normal <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- dat[,name]#
    n <- length(tmpDat)#
    xmax = data1$limit[1]#
    if (xmax == 0) { xmax = 1 }#
    ymax = data1$limit[2]#
    if (ymax == 0) { ymax = 1 }#
    plot(dat$time,#
         tmpDat,#
         xlim = c(0, xmax), ylim = c(0, ymax),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[1], " (", data1$unit[1], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$color), 1)]#
    plotdat#
}
# Copyright (c) 2015 by Matthieu Boutier#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy#
# of this software and associated documentation files (the "Software"), to deal#
# in the Software without restriction, including without limitation the rights#
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell#
# copies of the Software, and to permit persons to whom the Software is#
# furnished to do so, subject to the following conditions:#
#
# The above copyright notice and this permission notice shall be included in#
# all copies or substantial portions of the Software.#
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR#
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,#
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE#
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER#
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,#
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN#
# THE SOFTWARE.#
#
exit_usage <- function() {#
    print("usage: --args <file [file]*>")#
    print("usage: --args <directory [directory]>")#
    print("    ... and a lot of other options (see the code).")#
    q()#
}#
#
get_data_ping <- function(csvFile) {#
    csvData <- (read.table(csvFile, header=TRUE, sep="",#
                           colClasses=c("numeric", "numeric", "numeric", "numeric"))#
               )[c("timestamp", "rtt", "ttl", "seq")]#
    names(csvData) <- c("time", "rtt", "ttl", "seq")#
    t0 <- csvData[1,"time"]#
    csvData["time"] <- csvData[,"time"] - t0#
    csvData["ttl"] <- 64 - csvData[,"ttl"]#
#
    maxtime <- max(csvData$time, na.rm = TRUE)#
#
    dat1 <- list(data = csvData[c("time", "rtt")],#
        t0 = t0,#
        type = c("Time", "RTT"),#
        unit = c("s", "ms"),#
        limit = c(maxtime, max(csvData$rtt, na.rm = TRUE)),#
        summary = summary(csvData$rtt))#
#
    dat2 <- list(data = csvData[c("time", "ttl")],#
        t0 = t0,#
        type = c("Time", "Hop number: 64-TTL"),#
        unit = c("s", "hops"),#
        limit = c(maxtime, max(csvData$ttl, na.rm = TRUE)),#
        summary = summary(csvData$ttl))#
#
    # extract packet duplication#
    tmp <- aggregate(csvData["time"], FUN=max, by=list(seq=csvData$seq))["time"]#
    tmp["dup"] <- aggregate(rep(1, nrow(csvData)), FUN=sum,#
        by=list(seq=csvData$seq))$x - 1#
#
    dat3 <- list(data = tmp,#
        t0 = t0,#
        type = c("Time", "Duplicates"),#
        unit = c("s", "count"),#
        limit = c(maxtime, max(tmp$dup, na.rm = TRUE)),#
        summary = summary(tmp$dup))#
    list(dat1, dat2, dat3)#
}#
#
get_data_iperf <- function(csvFile) {#
    csvData <- (read.table(csvFile, sep=",", flush=TRUE,#
                           colClasses=c("character", "character", "numeric",#
                                        "character", "numeric", "numeric",#
                                        "character", "numeric", "numeric"))#
               )[c(1,7,9)]#
    # ignore the last two lines: these are summaries: client and server side.#
    csvData <- csvData[1:(nrow(csvData) - 2),]#
    t0 <- as.numeric(format(strptime(csvData$V1[1], format="%Y%m%d%H%M%S"), "%s"))#
    csvData$V1 <- NULL#
    names(csvData) <- c("time", "bitrate")#
    csvData$time <- as.numeric(sub("-.*", "", csvData$time))#
#
    dat1 <- list(data = csvData,#
        t0 = t0,#
        type = c("Time", "Throughput"),#
        unit = c("s", "bit/s"),#
        limit = c(max(csvData$time, na.rm = TRUE),#
            max(csvData$bitrate, na.rm = TRUE)),#
            summary = summary(csvData$bitrate))#
    list(dat1)#
}#
#
compute_data <- function(csvFile) {#
    extension <- sub(".*[.]", "", csvFile)#
    if(extension == "csv") {#
        get_data_ping(csvFile)#
    } else if (extension == "iperf"){#
        get_data_iperf(csvFile)#
    }#
}#
#
get_colors <- function(number) {#
#plot(seq(1,100), rep(c(1:10,9:2),10)[1:100], pch=as.character(rep(0:9,10)), col=hsv(seq(0,.99,by=.01),1,1), cex=3)#
    hue <- c(0, 9, 16, 29, 26, 36, 44, 50, 54, 58, 64, 72, 77, 81, 85, 91)#
    val <- c(1, 1, .8, .7,  1, .4,  1,  1,  1,  1,  1, .7,  1,  1,  1,  1)#
    sat <- c(1, 1, .7,  1,  1,  1,  1,  1,  1,  1, .5,  1,  1, .6,  1,  1)#
    col <- hsv(hue / 100, sat, val)#
#
    pref <- col[c(1, 2, 3, 4, 7, 8, 10, 12, 14)]#
#
    if (number == 1) {#
        ret <- c("#000000", "#000000")#
    } else if (number <= length(pref)) {#
        tmp <- floor(seq(1:number) * length(pref) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- pref[tmp]#
    } else if (number <= length(col)) {#
        tmp <- floor(seq(1:number) * length(col) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- col[tmp]#
    } else {#
        ret <- c("#000000", col)#
    }#
#   plot(rep(1, 16), pch=20, col = ret, cex = 8)#
    ret#
}#
#
# Draw axis and sub-graduations by hand.#
draw_axis <- function(i, color = "black") {#
    axis_labels = axis(i, col = color)#
    len = length(axis_labels)#
    maxVal = axis_labels[len] * 2#
    by_step = axis_labels[len] - axis_labels[len - 1]#
        axis(i, at = seq(from = 0, to = maxVal, by = by_step),#
             tcl = -.75, col = color)#
    first_digit = as.numeric(substr(as.character(by_step), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = 2#
    } else if (first_digit %% 5 == 0) {#
        div = 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.5 , col = color, labels = FALSE)#
    first_digit = as.numeric(substr(as.character(by_step/div), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = div * 2#
    } else if (first_digit %% 5 == 0) {#
        div = div * 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.25 , col = color, labels = FALSE)#
}#
#
draw_legend <- function(lnames, col, lty, pch) {#
    par(xpd = NA)#
    legend(flag_legend, legend = lnames,#
           col=col,#
           ncol=1, cex = 1,#
           lwd = 1, lty = lty, pch=pch,#
           inset = flag_legend_dec, bg = "white", x.intersp = 1)#
    par(xpd = FALSE)#
}#
#
open_device <- function(filename, type) {#
    filename <- sub(paste(".", type, "$", sep=""), "", filename)#
    filename = paste(filename, type, sep=".");#
    print(paste("drawing:", filename))#
    if(Sys.info()[["sysname"]] == "Darwin") {#
        # On MacOS, the best is to use quartz.#
        quartz(file = filename, width = flag_width,#
               height = flag_height, type = type, dpi=300)#
    } else {#
        # Works on Linux:#
        f_pixels <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height, units = "in", res = 300))#
        }#
        f_other <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height))#
        }#
        tryCatch(f_pixels(), error = function(e) {f_other()})#
    }#
}#
#
normalize <- function(data, min_t0, tmax, max_throughput) {#
    if (max_throughput > 1000000000) {#
        unit <- "Gbit/s"#
        factor <- 1000000000#
    } else if (max_throughput > 1000000) {#
        unit <- "Mbit/s"#
        factor <- 1000000#
    } else if (max_throughput > 1000) {#
        unit <- "Kbit/s"#
        factor <- 1000#
    } else {#
        unit <- "bit/s"#
        factor <- 1#
    }#
    i <- 1#
    while(i <= length(data)) {#
        data[[i]]$data$time <- data[[i]]$data$time + (data[[i]]$t0 - min_t0)#
        data[[i]]$tmax <- tmax#
        if (data[[i]]$unit[2] == "bit/s") {#
            data[[i]]$data$bitrate = data[[i]]$data$bitrate / factor#
            data[[i]]$limit[2] = data[[i]]$limit[2] / factor#
            data[[i]]$unit[2] = unit#
        }#
        i <- i + 1#
    }#
    data#
}#
#
rescale <- function(dat) {#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && flag_maxtime < Inf) {#
            dat$limit[i] = flag_maxtime#
            dat$data <- dat$data[dat$data$time <= flag_maxtime,]#
        } else if (dat$type[i] == "RTT" && flag_maxrtt < Inf) {#
            dat$limit[i] = flag_maxrtt#
        } else if (dat$type[i] == "Duplicates") {#
            # not implemented#
        } else if (dat$type[i] == "Hop number: 64-TTL") {#
            # not implemented#
        } else if (dat$type[i] == "Throughput") {#
            # not implemented#
        }#
    }#
    dat#
}#
#
draw_ecdf <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- sort(dat[,name])#
    n <- length(tmpDat)#
    xmax = data1$limit[2]#
    if (xmax == 0) { xmax = 1 }#
    plot(tmpDat,#
         (1:n) / n,#
         xlim = c(0, xmax), ylim = c(0, 1),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5, lwd = 2,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$color), 1)]#
    plotdat#
}#
#
draw_normal <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- dat[,name]#
    n <- length(tmpDat)#
    xmax = data1$limit[1]#
    if (xmax == 0) { xmax = 1 }#
    ymax = data1$limit[2]#
    if (ymax == 0) { ymax = 1 }#
    plot(dat$time,#
         tmpDat,#
         xlim = c(0, xmax), ylim = c(0, ymax),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    color <- color + 1#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[1], " (", data1$unit[1], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$color), 1)]#
    plotdat#
}
reset_plotdat <- function() {#
    list(legend_col = c(), legend_pch = c(), legend_lty = c(),#
        point_type = 0, line_type = 1, color = flag_palette)#
}#
#
new_page <- function(force_separated=FALSE) {#
    if (force_separated || flag_separate_output) {#
        par(mfrow = c(1, 1), mar = c(3,4,1,1) + 0.1, bg = "white")#
    } else {#
        par(mfrow = c(2, 2), mar = c(3,4,1,1) + 0.1, bg = "white")#
    }#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE)#
    par(new = TRUE)#
#
    reset_plotdat()#
}
draw_graph <- function(csvFiles) {#
    data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }#
#
    # normalize data#
    data <- normalize(data, min_t0, tmax, max_throughput)#
#
    # choose the palette#
    if (length(flag_palette == 0) {#
        flag_palette <<- get_colors(curve_num))#
    }#
#
    # set output#
    open_device(flag_filename, flag_output_type)#
#
    # Draw ECDF curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, FALSE)#
    }#
#
    plotdat <- reset_plotdat()#
    # Draw all together#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(2)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
    mtext("All together (no scale)", 1, line = 1, las = 0)#
#
    # Draw normal curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, FALSE)#
    }#
#
    # Draw all together#
    plotdat <- reset_plotdat()#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(1)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext("All together (no scale)", 2, line = 1, las = 0)#
    mtext(paste(sep="", data[[1]]$type[1], " (", data[[1]]$unit[1], ")"),#
          1, line = 2, las = 0)#
#
#    draw_legend(legend_names, legend_col, legend_lty, legend_pch)#
#    mtext(document_name, side = 3, line = 2, cex = 2.2, las = 0)#
#
    rc <- dev.off()#
    data#
}
draw_graph <- function(csvFiles) {#
    data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }#
#
    # normalize data#
    data <- normalize(data, min_t0, tmax, max_throughput)#
#
    # choose the palette#
    if (length(flag_palette == 0) {#
        flag_palette <<- get_colors(curve_num))#
    }
get_colors(curve_num)
get_colors(3)
draw_graph <- function(csvFiles) {#
    data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }#
#
    # normalize data#
    data <- normalize(data, min_t0, tmax, max_throughput)#
#
    # choose the palette#
    if (length(flag_palette == 0) {#
        flag_palette <<- get_colors(curve_num)#
    }#
#
    # set output#
    open_device(flag_filename, flag_output_type)#
#
    # Draw ECDF curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, FALSE)#
    }#
#
    plotdat <- reset_plotdat()#
    # Draw all together#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(2)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
    mtext("All together (no scale)", 1, line = 1, las = 0)#
#
    # Draw normal curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, FALSE)#
    }#
#
    # Draw all together#
    plotdat <- reset_plotdat()#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(1)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext("All together (no scale)", 2, line = 1, las = 0)#
    mtext(paste(sep="", data[[1]]$type[1], " (", data[[1]]$unit[1], ")"),#
          1, line = 2, las = 0)#
#
#    draw_legend(legend_names, legend_col, legend_lty, legend_pch)#
#    mtext(document_name, side = 3, line = 2, cex = 2.2, las = 0)#
#
    rc <- dev.off()#
    data#
}
draw_graph <- function(csvFiles) {#
    data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }
data <- normalize(data, min_t0, tmax, max_throughput)
# choose the palette#
    if (length(flag_palette == 0) {#
        flag_palette <<- get_colors(curve_num)#
    }
draw_graph <- function(csvFiles) {#
    data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }#
#
    # normalize data#
    data <- normalize(data, min_t0, tmax, max_throughput)#
#
    # choose the palette#
    if (length(flag_palette == 0)) {#
        flag_palette <<- get_colors(curve_num)#
    }
open_device(flag_filename, flag_output_type)#
#
    # Draw ECDF curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, FALSE)#
    }#
#
    plotdat <- reset_plotdat()#
    # Draw all together#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(2)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
    mtext("All together (no scale)", 1, line = 1, las = 0)#
#
    # Draw normal curves#
    plotdat <- new_page()#
#
    # Draw single plots
for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, FALSE)#
    }#
#
    # Draw all together#
    plotdat <- reset_plotdat()#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(1)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext("All together (no scale)", 2, line = 1, las = 0)#
    mtext(paste(sep="", data[[1]]$type[1], " (", data[[1]]$unit[1], ")"),#
          1, line = 2, las = 0)#
#
#    draw_legend(legend_names, legend_col, legend_lty, legend_pch)#
#    mtext(document_name, side = 3, line = 2, cex = 2.2, las = 0)#
#
    rc <- dev.off()#
    data#
}
`[.dataclass` <- function(x,i) {#
    class(x) <- "list"#
    structure(x[i], class="dataclass")#
}#
#
`>.dataclass` <- function(e1, e2) {#
    e1[[1]]$type[2] > e2[[1]]$type[2] ||#
    e1[[1]]$summary["3rd Qu."] > e2[[1]]$summary["3rd Qu."]#
}#
#
`==.dataclass` <- function(e1, e2) {#
    e1[[1]]$type[2] == e2[[1]]$type[2] &&#
    e1[[1]]$summary["3rd Qu."] == e2[[1]]$summary["3rd Qu."]#
}#
#
draw_summary <- function(data) {#
    print("Draw summary")#
    class(data) <- "dataclass"#
    data <- sort(data)#
    type <- data[[1]]$type[2]#
#
    # ecdf summaries#
    open_device(paste(names(data[[1]]$data)[2], "-ecdf-summary", sep=""), flag_output_type)#
    palette(get_colors(1))#
    for (dat in data) {#
        if (type != dat$type[2]) {#
                type <- dat$type[2]#
                dev.off()#
            open_device(paste(names(dat$data)[2], "-ecdf-summary", sep=""), flag_output_type)#
            plotdat <- new_page(force_separated = TRUE)#
        }#
        plotdat <- reset_plotdat()#
        plotdat <- draw_ecdf(dat, plotdat, FALSE)#
        mtext(dat$name, side = 3, line = 0, cex = 1, las = 0)#
    }#
    dev.off()#
#
    # standard summaries#
    open_device(paste(names(data[[1]]$data)[2], "-std-summary", sep=""), flag_output_type)#
    palette(get_colors(1))#
    for (dat in data) {#
        if (type != dat$type[2]) {#
                type <- dat$type[2]#
                dev.off()#
            open_device(paste(names(dat$data)[2], "-std-summary", sep=""), flag_output_type)#
            plotdat <- new_page(force_separated = TRUE)#
        }#
        plotdat <- reset_plotdat()#
        plotdat <- draw_normal(dat, plotdat, FALSE)#
        mtext(dat$name, side = 3, line = 0, cex = 1, las = 0)#
    }#
    dev.off()#
}
enter <- function(pwd) {#
    data <- NULL#
    print(paste("entering", pwd))#
    setwd(pwd)#
    csvFiles <- list.files(".", pattern="^(ping[.]csv|iperf)$", recursive=FALSE)#
    if(length(csvFiles) > 0) {#
        tryCatch({#
            data <- draw_graph(csvFiles)#
        }, error = function(w) {#
            print(paste(w))#
        })#
    } else {#
        alldata <- list()#
        subdir <- basename(list.dirs(".", recursive=FALSE))#
        for(d in subdir) {#
            data <- enter(paste(pwd, d, sep="/"))#
            if (is.null(data)) next#
            setwd(pwd)#
            for (i in 1:length(data)) {#
                data[[i]]$name <- d#
            }#
            alldata <- c(alldata, data)#
        }#
        if(length(alldata) > 0) {#
            draw_summary(alldata)#
            data <- NULL#
        }#
    }#
    data#
}
col
legend(flag_legend, legend = lnames,#
           col=col,#
           ncol=1, cex = 1,#
           lwd = 1, lty = lty, pch=pch,#
           inset = flag_legend_dec, bg = "white", x.intersp = 1)
legend(o, "a")
legend("o", "a")
legend("top", "a")
legend("top", "a", col="#FF00FF")
legend("top", c("a", "b"), col=c("#FF0000", "#0000FF"))
legend("top", c("a", "b"), col=c("#FF0000", "#0000FF"), lwd = 1, lty=c(1,2))))
legend("top", c("a", "b"), col=c("#FF0000", "#0000FF"), lwd = 1, lty=c(1,2)))
legend("top", c("a", "b"), col=c("#FF0000", "#0000FF"), lwd = 1, lty=c(1,2))
pwd
basename(pwd)
rm(list=ls())
flag_maxtime <- Inf#
flag_maxrtt <- Inf#
flag_lang <- "en"#
flag_width <- 12.8#
flag_height <- 8#
flag_filename <- "generic"#
flag_output_type <- "pdf"#
flag_separate_output <- FALSE#
flag_grid <- FALSE#
flag_palette <<- NULL#
recurse <- TRUE#
txt_title <- ""
enter <- function(pwd) {#
    data <- NULL#
    print(paste("entering", pwd))#
    setwd(pwd)#
    csvFiles <- list.files(".", pattern="^(ping[.]csv|iperf)$", recursive=FALSE)#
    if(length(csvFiles) > 0) {#
        tryCatch({#
            data <- draw_graph(csvFiles, basename(pwd))#
        }, error = function(w) {#
            print(paste(w))#
        })#
    } else {#
        alldata <- list()#
        subdir <- basename(list.dirs(".", recursive=FALSE))#
        for(d in subdir) {#
            data <- enter(paste(pwd, d, sep="/"))#
            if (is.null(data)) next#
            setwd(pwd)#
            for (i in 1:length(data)) {#
                data[[i]]$name <- d#
            }#
            alldata <- c(alldata, data)#
        }#
        if(length(alldata) > 0) {#
            draw_summary(alldata)#
            data <- NULL#
        }#
    }#
    data#
}
# Copyright (c) 2015 by Matthieu Boutier#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy#
# of this software and associated documentation files (the "Software"), to deal#
# in the Software without restriction, including without limitation the rights#
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell#
# copies of the Software, and to permit persons to whom the Software is#
# furnished to do so, subject to the following conditions:#
#
# The above copyright notice and this permission notice shall be included in#
# all copies or substantial portions of the Software.#
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR#
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,#
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE#
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER#
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,#
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN#
# THE SOFTWARE.#
#
exit_usage <- function() {#
    print("usage: --args <file [file]*>")#
    print("usage: --args <directory [directory]>")#
    print("    ... and a lot of other options (see the code).")#
    q()#
}#
#
get_data_ping <- function(csvFile) {#
    csvData <- (read.table(csvFile, header=TRUE, sep="",#
                           colClasses=c("numeric", "numeric", "numeric", "numeric"))#
               )[c("timestamp", "rtt", "ttl", "seq")]#
    names(csvData) <- c("time", "rtt", "ttl", "seq")#
    t0 <- csvData[1,"time"]#
    csvData["time"] <- csvData[,"time"] - t0#
    csvData["ttl"] <- 64 - csvData[,"ttl"]#
#
    maxtime <- max(csvData$time, na.rm = TRUE)#
#
    dat1 <- list(data = csvData[c("time", "rtt")],#
        t0 = t0,#
        type = c("Time", "RTT"),#
        unit = c("s", "ms"),#
        limit = c(maxtime, max(csvData$rtt, na.rm = TRUE)),#
        summary = summary(csvData$rtt))#
#
    dat2 <- list(data = csvData[c("time", "ttl")],#
        t0 = t0,#
        type = c("Time", "Hop number: 64-TTL"),#
        unit = c("s", "hops"),#
        limit = c(maxtime, max(csvData$ttl, na.rm = TRUE)),#
        summary = summary(csvData$ttl))#
#
    # extract packet duplication#
    tmp <- aggregate(csvData["time"], FUN=max, by=list(seq=csvData$seq))["time"]#
    tmp["dup"] <- aggregate(rep(1, nrow(csvData)), FUN=sum,#
        by=list(seq=csvData$seq))$x - 1#
#
    dat3 <- list(data = tmp,#
        t0 = t0,#
        type = c("Time", "Duplicates"),#
        unit = c("s", "count"),#
        limit = c(maxtime, max(tmp$dup, na.rm = TRUE)),#
        summary = summary(tmp$dup))#
    list(dat1, dat2, dat3)#
}#
#
get_data_iperf <- function(csvFile) {#
    csvData <- (read.table(csvFile, sep=",", flush=TRUE,#
                           colClasses=c("character", "character", "numeric",#
                                        "character", "numeric", "numeric",#
                                        "character", "numeric", "numeric"))#
               )[c(1,7,9)]#
    # ignore the last two lines: these are summaries: client and server side.#
    csvData <- csvData[1:(nrow(csvData) - 2),]#
    t0 <- as.numeric(format(strptime(csvData$V1[1], format="%Y%m%d%H%M%S"), "%s"))#
    csvData$V1 <- NULL#
    names(csvData) <- c("time", "bitrate")#
    csvData$time <- as.numeric(sub("-.*", "", csvData$time))#
#
    dat1 <- list(data = csvData,#
        t0 = t0,#
        type = c("Time", "Throughput"),#
        unit = c("s", "bit/s"),#
        limit = c(max(csvData$time, na.rm = TRUE),#
            max(csvData$bitrate, na.rm = TRUE)),#
            summary = summary(csvData$bitrate))#
    list(dat1)#
}#
#
compute_data <- function(csvFile) {#
    extension <- sub(".*[.]", "", csvFile)#
    if(extension == "csv") {#
        get_data_ping(csvFile)#
    } else if (extension == "iperf"){#
        get_data_iperf(csvFile)#
    }#
}#
#
get_colors <- function(number) {#
#plot(seq(1,100), rep(c(1:10,9:2),10)[1:100], pch=as.character(rep(0:9,10)), col=hsv(seq(0,.99,by=.01),1,1), cex=3)#
    hue <- c(0, 9, 16, 29, 26, 36, 44, 50, 54, 58, 64, 72, 77, 81, 85, 91)#
    val <- c(1, 1, .8, .7,  1, .4,  1,  1,  1,  1,  1, .7,  1,  1,  1,  1)#
    sat <- c(1, 1, .7,  1,  1,  1,  1,  1,  1,  1, .5,  1,  1, .6,  1,  1)#
    col <- hsv(hue / 100, sat, val)#
#
    pref <- col[c(1, 2, 3, 4, 7, 8, 10, 12, 14)]#
#
    if (number == 1) {#
        ret <- c("#000000", "#000000")#
    } else if (number <= length(pref)) {#
        tmp <- floor(seq(1:number) * length(pref) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- pref[tmp]#
    } else if (number <= length(col)) {#
        tmp <- floor(seq(1:number) * length(col) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- col[tmp]#
    } else {#
        ret <- c("#000000", col)#
    }#
#   plot(rep(1, 16), pch=20, col = ret, cex = 8)#
    ret#
}#
#
# Draw axis and sub-graduations by hand.#
draw_axis <- function(i, color = "black") {#
    axis_labels = axis(i, col = color)#
    len = length(axis_labels)#
    maxVal = axis_labels[len] * 2#
    by_step = axis_labels[len] - axis_labels[len - 1]#
        axis(i, at = seq(from = 0, to = maxVal, by = by_step),#
             tcl = -.75, col = color)#
    first_digit = as.numeric(substr(as.character(by_step), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = 2#
    } else if (first_digit %% 5 == 0) {#
        div = 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.5 , col = color, labels = FALSE)#
    first_digit = as.numeric(substr(as.character(by_step/div), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = div * 2#
    } else if (first_digit %% 5 == 0) {#
        div = div * 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.25 , col = color, labels = FALSE)#
}#
#
draw_legend <- function(lnames, col, lty, pch) {#
    par(xpd = NA)#
    legend(flag_legend, legend = lnames,#
           col=col,#
           ncol=1, cex = 1,#
           lwd = 1, lty = lty, pch=pch,#
           inset = flag_legend_dec, bg = "white", x.intersp = 1)#
    par(xpd = FALSE)#
}#
#
open_device <- function(filename, type) {#
    filename <- sub(paste(".", type, "$", sep=""), "", filename)#
    filename = paste(filename, type, sep=".");#
    print(paste("drawing:", filename))#
    if(Sys.info()[["sysname"]] == "Darwin") {#
        # On MacOS, the best is to use quartz.#
        quartz(file = filename, width = flag_width,#
               height = flag_height, type = type, dpi=300)#
    } else {#
        # Works on Linux:#
        f_pixels <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height, units = "in", res = 300))#
        }#
        f_other <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height))#
        }#
        tryCatch(f_pixels(), error = function(e) {f_other()})#
    }#
}#
#
normalize <- function(data, min_t0, tmax, max_throughput) {#
    if (max_throughput > 1000000000) {#
        unit <- "Gbit/s"#
        factor <- 1000000000#
    } else if (max_throughput > 1000000) {#
        unit <- "Mbit/s"#
        factor <- 1000000#
    } else if (max_throughput > 1000) {#
        unit <- "Kbit/s"#
        factor <- 1000#
    } else {#
        unit <- "bit/s"#
        factor <- 1#
    }#
    i <- 1#
    while(i <= length(data)) {#
        data[[i]]$data$time <- data[[i]]$data$time + (data[[i]]$t0 - min_t0)#
        data[[i]]$tmax <- tmax#
        if (data[[i]]$unit[2] == "bit/s") {#
            data[[i]]$data$bitrate = data[[i]]$data$bitrate / factor#
            data[[i]]$limit[2] = data[[i]]$limit[2] / factor#
            data[[i]]$unit[2] = unit#
        }#
        i <- i + 1#
    }#
    data#
}#
#
rescale <- function(dat) {#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && flag_maxtime < Inf) {#
            dat$limit[i] = flag_maxtime#
            dat$data <- dat$data[dat$data$time <= flag_maxtime,]#
        } else if (dat$type[i] == "RTT" && flag_maxrtt < Inf) {#
            dat$limit[i] = flag_maxrtt#
        } else if (dat$type[i] == "Duplicates") {#
            # not implemented#
        } else if (dat$type[i] == "Hop number: 64-TTL") {#
            # not implemented#
        } else if (dat$type[i] == "Throughput") {#
            # not implemented#
        }#
    }#
    dat#
}#
#
draw_ecdf <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- sort(dat[,name])#
    n <- length(tmpDat)#
    xmax = data1$limit[2]#
    if (xmax == 0) { xmax = 1 }#
    plot(tmpDat,#
         (1:n) / n,#
         xlim = c(0, xmax), ylim = c(0, 1),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5, lwd = 2,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$color), 1)]#
    plotdat#
}#
#
draw_normal <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- dat[,name]#
    n <- length(tmpDat)#
    xmax = data1$limit[1]#
    if (xmax == 0) { xmax = 1 }#
    ymax = data1$limit[2]#
    if (ymax == 0) { ymax = 1 }#
    plot(dat$time,#
         tmpDat,#
         xlim = c(0, xmax), ylim = c(0, ymax),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[1], " (", data1$unit[1], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$color), 1)]#
    plotdat#
}#
#
reset_plotdat <- function() {#
    list(legend_col = c(), legend_pch = c(), legend_lty = c(),#
        point_type = 0, line_type = 1, color = flag_palette)#
}#
#
new_page <- function(force_separated=FALSE) {#
    if (force_separated || flag_separate_output) {#
        par(mfrow = c(1, 1), mar = c(3,4,1,1) + 0.1, bg = "white")#
    } else {#
        par(mfrow = c(2, 2), mar = c(3,4,1,1) + 0.1, bg = "white")#
    }#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE)#
    par(new = TRUE)#
#
    reset_plotdat()#
}#
#
draw_graph <- function(csvFiles, filename="generic") {#
    data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }#
#
    # normalize data#
    data <- normalize(data, min_t0, tmax, max_throughput)#
#
    # choose the palette#
    if (length(flag_palette == 0)) {#
        flag_palette <<- get_colors(curve_num)#
    }#
#
    # set output#
    open_device(filename, flag_output_type)#
#
    # Draw ECDF curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, FALSE)#
    }#
#
    plotdat <- reset_plotdat()#
    # Draw all together#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(2)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
    mtext("All together (no scale)", 1, line = 1, las = 0)#
#
    # Draw normal curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, FALSE)#
    }#
#
    # Draw all together#
    plotdat <- reset_plotdat()#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(1)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext("All together (no scale)", 2, line = 1, las = 0)#
    mtext(paste(sep="", data[[1]]$type[1], " (", data[[1]]$unit[1], ")"),#
          1, line = 2, las = 0)#
#
#    draw_legend(legend_names, legend_col, legend_lty, legend_pch)#
#    mtext(document_name, side = 3, line = 2, cex = 2.2, las = 0)#
#
    rc <- dev.off()#
    data#
}#
#
`[.dataclass` <- function(x,i) {#
    class(x) <- "list"#
    structure(x[i], class="dataclass")#
}#
#
`>.dataclass` <- function(e1, e2) {#
    e1[[1]]$type[2] > e2[[1]]$type[2] ||#
    e1[[1]]$summary["3rd Qu."] > e2[[1]]$summary["3rd Qu."]#
}#
#
`==.dataclass` <- function(e1, e2) {#
    e1[[1]]$type[2] == e2[[1]]$type[2] &&#
    e1[[1]]$summary["3rd Qu."] == e2[[1]]$summary["3rd Qu."]#
}#
#
draw_summary <- function(data) {#
    print("Draw summary")#
    class(data) <- "dataclass"#
    data <- sort(data)#
    type <- data[[1]]$type[2]#
    flag_palette <<- "#0000FF"#
#
    # ecdf summaries#
    open_device(paste(names(data[[1]]$data)[2], "-ecdf-summary", sep=""), flag_output_type)#
    for (dat in data) {#
        if (type != dat$type[2]) {#
                type <- dat$type[2]#
                dev.off()#
            open_device(paste(names(dat$data)[2], "-ecdf-summary", sep=""), flag_output_type)#
            plotdat <- new_page(force_separated = TRUE)#
        }#
        plotdat <- reset_plotdat()#
        plotdat <- draw_ecdf(dat, plotdat, FALSE)#
        mtext(dat$name, side = 3, line = 0, cex = 1, las = 0)#
    }#
    dev.off()#
#
    # standard summaries#
    open_device(paste(names(data[[1]]$data)[2], "-std-summary", sep=""), flag_output_type)#
    for (dat in data) {#
        if (type != dat$type[2]) {#
                type <- dat$type[2]#
                dev.off()#
            open_device(paste(names(dat$data)[2], "-std-summary", sep=""), flag_output_type)#
            plotdat <- new_page(force_separated = TRUE)#
        }#
        plotdat <- reset_plotdat()#
        plotdat <- draw_normal(dat, plotdat, FALSE)#
        mtext(dat$name, side = 3, line = 0, cex = 1, las = 0)#
    }#
    dev.off()#
}
x <- 1
f <- function() { x <<- 2 }
x
f()
x
x <- 3
g <- function() { x }
g()
f()
g()
flag_palette
flag_palette <- c("#000000", "#FF0000", "#0000FF")
flag_palette
csvFiles <- list.files(".", pattern="^(ping[.]csv|iperf)$", recursive=FALSE)
csvFiles
getwd()
data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }#
#
    # normalize data#
    data <- normalize(data, min_t0, tmax, max_throughput)
flag_palette
length(flag_palette == 0)
setwd("~/programmation/benchs/BMv8/results/001-20150808/4/Babel")
csvFiles <- list.files(".", pattern="^(ping[.]csv|iperf)$", recursive=FALSE)
data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }#
#
    # normalize data#
    data <- normalize(data, min_t0, tmax, max_throughput)
data
flag_palette
flag_palette <<- strsplit(argv[i+1], " ")[[1]]
flag_palette <<- strsplit("#FF0000 #005500 #0000FF #000000", " ")[[1]]
flag_palette
plotdat <- new_page()
for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, FALSE)#
    }
rm(list=ls())
flag_maxtime <- Inf#
flag_maxrtt <- Inf#
flag_lang <- "en"#
flag_width <- 12.8#
flag_height <- 8#
flag_filename <- "generic"#
flag_output_type <- "pdf"#
flag_separate_output <- FALSE#
flag_grid <- FALSE#
flag_palette <<- NULL#
recurse <- TRUE#
txt_title <- ""
# Copyright (c) 2015 by Matthieu Boutier#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy#
# of this software and associated documentation files (the "Software"), to deal#
# in the Software without restriction, including without limitation the rights#
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell#
# copies of the Software, and to permit persons to whom the Software is#
# furnished to do so, subject to the following conditions:#
#
# The above copyright notice and this permission notice shall be included in#
# all copies or substantial portions of the Software.#
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR#
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,#
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE#
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER#
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,#
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN#
# THE SOFTWARE.#
#
exit_usage <- function() {#
    print("usage: --args <file [file]*>")#
    print("usage: --args <directory [directory]>")#
    print("    ... and a lot of other options (see the code).")#
    q()#
}#
#
get_data_ping <- function(csvFile) {#
    csvData <- (read.table(csvFile, header=TRUE, sep="",#
                           colClasses=c("numeric", "numeric", "numeric", "numeric"))#
               )[c("timestamp", "rtt", "ttl", "seq")]#
    names(csvData) <- c("time", "rtt", "ttl", "seq")#
    t0 <- csvData[1,"time"]#
    csvData["time"] <- csvData[,"time"] - t0#
    csvData["ttl"] <- 64 - csvData[,"ttl"]#
#
    maxtime <- max(csvData$time, na.rm = TRUE)#
#
    dat1 <- list(data = csvData[c("time", "rtt")],#
        t0 = t0,#
        type = c("Time", "RTT"),#
        unit = c("s", "ms"),#
        limit = c(maxtime, max(csvData$rtt, na.rm = TRUE)),#
        summary = summary(csvData$rtt))#
#
    dat2 <- list(data = csvData[c("time", "ttl")],#
        t0 = t0,#
        type = c("Time", "Hop number: 64-TTL"),#
        unit = c("s", "hops"),#
        limit = c(maxtime, max(csvData$ttl, na.rm = TRUE)),#
        summary = summary(csvData$ttl))#
#
    # extract packet duplication#
    tmp <- aggregate(csvData["time"], FUN=max, by=list(seq=csvData$seq))["time"]#
    tmp["dup"] <- aggregate(rep(1, nrow(csvData)), FUN=sum,#
        by=list(seq=csvData$seq))$x - 1#
#
    dat3 <- list(data = tmp,#
        t0 = t0,#
        type = c("Time", "Duplicates"),#
        unit = c("s", "count"),#
        limit = c(maxtime, max(tmp$dup, na.rm = TRUE)),#
        summary = summary(tmp$dup))#
    list(dat1, dat2, dat3)#
}#
#
get_data_iperf <- function(csvFile) {#
    csvData <- (read.table(csvFile, sep=",", flush=TRUE,#
                           colClasses=c("character", "character", "numeric",#
                                        "character", "numeric", "numeric",#
                                        "character", "numeric", "numeric"))#
               )[c(1,7,9)]#
    # ignore the last two lines: these are summaries: client and server side.#
    csvData <- csvData[1:(nrow(csvData) - 2),]#
    t0 <- as.numeric(format(strptime(csvData$V1[1], format="%Y%m%d%H%M%S"), "%s"))#
    csvData$V1 <- NULL#
    names(csvData) <- c("time", "bitrate")#
    csvData$time <- as.numeric(sub("-.*", "", csvData$time))#
#
    dat1 <- list(data = csvData,#
        t0 = t0,#
        type = c("Time", "Throughput"),#
        unit = c("s", "bit/s"),#
        limit = c(max(csvData$time, na.rm = TRUE),#
            max(csvData$bitrate, na.rm = TRUE)),#
            summary = summary(csvData$bitrate))#
    list(dat1)#
}#
#
compute_data <- function(csvFile) {#
    extension <- sub(".*[.]", "", csvFile)#
    if(extension == "csv") {#
        get_data_ping(csvFile)#
    } else if (extension == "iperf"){#
        get_data_iperf(csvFile)#
    }#
}#
#
get_colors <- function(number) {#
#plot(seq(1,100), rep(c(1:10,9:2),10)[1:100], pch=as.character(rep(0:9,10)), col=hsv(seq(0,.99,by=.01),1,1), cex=3)#
    hue <- c(0, 9, 16, 29, 26, 36, 44, 50, 54, 58, 64, 72, 77, 81, 85, 91)#
    val <- c(1, 1, .8, .7,  1, .4,  1,  1,  1,  1,  1, .7,  1,  1,  1,  1)#
    sat <- c(1, 1, .7,  1,  1,  1,  1,  1,  1,  1, .5,  1,  1, .6,  1,  1)#
    col <- hsv(hue / 100, sat, val)#
#
    pref <- col[c(1, 2, 3, 4, 7, 8, 10, 12, 14)]#
#
    if (number == 1) {#
        ret <- c("#000000", "#000000")#
    } else if (number <= length(pref)) {#
        tmp <- floor(seq(1:number) * length(pref) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- pref[tmp]#
    } else if (number <= length(col)) {#
        tmp <- floor(seq(1:number) * length(col) / number)#
        tmp <- tmp - tmp[1] + 1#
        ret <- col[tmp]#
    } else {#
        ret <- c("#000000", col)#
    }#
#   plot(rep(1, 16), pch=20, col = ret, cex = 8)#
    ret#
}#
#
# Draw axis and sub-graduations by hand.#
draw_axis <- function(i, color = "black") {#
    axis_labels = axis(i, col = color)#
    len = length(axis_labels)#
    maxVal = axis_labels[len] * 2#
    by_step = axis_labels[len] - axis_labels[len - 1]#
        axis(i, at = seq(from = 0, to = maxVal, by = by_step),#
             tcl = -.75, col = color)#
    first_digit = as.numeric(substr(as.character(by_step), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = 2#
    } else if (first_digit %% 5 == 0) {#
        div = 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.5 , col = color, labels = FALSE)#
    first_digit = as.numeric(substr(as.character(by_step/div), 1, 1))#
    if (first_digit == 1 || first_digit %% 2 == 0) {#
        div = div * 2#
    } else if (first_digit %% 5 == 0) {#
        div = div * 5#
    }#
    axis(i, at = seq(from = 0, to = maxVal, by = by_step/div),#
         tcl = -.25 , col = color, labels = FALSE)#
}#
#
draw_legend <- function(lnames, col, lty, pch) {#
    par(xpd = NA)#
    legend(flag_legend, legend = lnames,#
           col=col,#
           ncol=1, cex = 1,#
           lwd = 1, lty = lty, pch=pch,#
           inset = flag_legend_dec, bg = "white", x.intersp = 1)#
    par(xpd = FALSE)#
}#
#
open_device <- function(filename, type) {#
    filename <- sub(paste(".", type, "$", sep=""), "", filename)#
    filename = paste(filename, type, sep=".");#
    print(paste("drawing:", filename))#
    if(Sys.info()[["sysname"]] == "Darwin") {#
        # On MacOS, the best is to use quartz.#
        quartz(file = filename, width = flag_width,#
               height = flag_height, type = type, dpi=300)#
    } else {#
        # Works on Linux:#
        f_pixels <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height, units = "in", res = 300))#
        }#
        f_other <- function() {#
            do.call(type, list(file = filename, width = flag_width,#
                    height = flag_height))#
        }#
        tryCatch(f_pixels(), error = function(e) {f_other()})#
    }#
}#
#
normalize <- function(data, min_t0, tmax, max_throughput) {#
    if (max_throughput > 1000000000) {#
        unit <- "Gbit/s"#
        factor <- 1000000000#
    } else if (max_throughput > 1000000) {#
        unit <- "Mbit/s"#
        factor <- 1000000#
    } else if (max_throughput > 1000) {#
        unit <- "Kbit/s"#
        factor <- 1000#
    } else {#
        unit <- "bit/s"#
        factor <- 1#
    }#
    i <- 1#
    while(i <= length(data)) {#
        data[[i]]$data$time <- data[[i]]$data$time + (data[[i]]$t0 - min_t0)#
        data[[i]]$tmax <- tmax#
        if (data[[i]]$unit[2] == "bit/s") {#
            data[[i]]$data$bitrate = data[[i]]$data$bitrate / factor#
            data[[i]]$limit[2] = data[[i]]$limit[2] / factor#
            data[[i]]$unit[2] = unit#
        }#
        i <- i + 1#
    }#
    data#
}#
#
rescale <- function(dat) {#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && flag_maxtime < Inf) {#
            dat$limit[i] = flag_maxtime#
            dat$data <- dat$data[dat$data$time <= flag_maxtime,]#
        } else if (dat$type[i] == "RTT" && flag_maxrtt < Inf) {#
            dat$limit[i] = flag_maxrtt#
        } else if (dat$type[i] == "Duplicates") {#
            # not implemented#
        } else if (dat$type[i] == "Hop number: 64-TTL") {#
            # not implemented#
        } else if (dat$type[i] == "Throughput") {#
            # not implemented#
        }#
    }#
    dat#
}#
#
draw_ecdf <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- sort(dat[,name])#
    n <- length(tmpDat)#
    xmax = data1$limit[2]#
    if (xmax == 0) { xmax = 1 }#
    plot(tmpDat,#
         (1:n) / n,#
         xlim = c(0, xmax), ylim = c(0, 1),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5, lwd = 2,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$color), 1)]#
    plotdat#
}#
#
draw_normal <- function(data1, plotdat, stack_graph) {#
    dat <- data1$data#
    name <- names(dat)[2]#
    point_type <- plotdat$point_type#
    line_type <- plotdat$line_type#
    color <- plotdat$color[1]#
    if(stack_graph)#
        par(new = TRUE)#
    tmpDat <- dat[,name]#
    n <- length(tmpDat)#
    xmax = data1$limit[1]#
    if (xmax == 0) { xmax = 1 }#
    ymax = data1$limit[2]#
    if (ymax == 0) { ymax = 1 }#
    plot(dat$time,#
         tmpDat,#
         xlim = c(0, xmax), ylim = c(0, ymax),#
         xlab = "", ylab = "",#
         pch = point_type, col = color, cex = .5,#
         bty = "o", type = "s",#
         axes = FALSE, lty = line_type)#
    plotdat$legend_col   <- c(plotdat$legend_col, color)#
    plotdat$legend_lty   <- c(plotdat$legend_lty, line_type)#
    plotdat$legend_pch   <- c(plotdat$legend_pch, point_type)#
    point_type <- (point_type + 1) %% 25#
    line_type <- (line_type %% 6) + 1#
    if(!stack_graph) {#
        draw_axis(2)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[2], " (", data1$unit[2], ")"),#
              2, line = 2, las = 0)#
#
        draw_axis(1)#
        if (flag_grid) {#
            grid(nx=NULL, ny=NA)#
        }#
        mtext(paste(sep="", data1$type[1], " (", data1$unit[1], ")"),#
              1, line = 2, las = 0)#
    }#
    plotdat$point_type <- point_type#
    plotdat$line_type <- line_type#
    plotdat$color <- plotdat$color[c(2:length(plotdat$color), 1)]#
    plotdat#
}#
#
reset_plotdat <- function() {#
    list(legend_col = c(), legend_pch = c(), legend_lty = c(),#
        point_type = 0, line_type = 1, color = flag_palette)#
}#
#
new_page <- function(force_separated=FALSE) {#
    if (force_separated || flag_separate_output) {#
        par(mfrow = c(1, 1), mar = c(3,4,1,1) + 0.1, bg = "white")#
    } else {#
        par(mfrow = c(2, 2), mar = c(3,4,1,1) + 0.1, bg = "white")#
    }#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE)#
    par(new = TRUE)#
#
    reset_plotdat()#
}#
#
draw_graph <- function(csvFiles, filename="generic") {#
    data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }#
#
    # normalize data#
    data <- normalize(data, min_t0, tmax, max_throughput)#
#
    # choose the palette#
    if (length(flag_palette) == 0) {#
        flag_palette <<- get_colors(curve_num)#
    }#
#
    # set output#
    open_device(filename, flag_output_type)#
#
    # Draw ECDF curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, FALSE)#
    }#
#
    plotdat <- reset_plotdat()#
    # Draw all together#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(2)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext(expression(hat(F)[n](x)), 2, line = 2, las = 0)#
    mtext("All together (no scale)", 1, line = 1, las = 0)#
#
    # Draw normal curves#
    plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, FALSE)#
    }#
#
    # Draw all together#
    plotdat <- reset_plotdat()#
    plot(0, type="n", xlab="", ylab="", main="", axes = FALSE) # create empty graph.#
    for (i in 1:length(data)) {#
        plotdat <- draw_normal(data[[i]], plotdat, TRUE)#
    }#
    box(bty="l")#
    draw_axis(1)#
    if (flag_grid) {#
        grid(nx=NULL, ny=NA)#
    }#
    mtext("All together (no scale)", 2, line = 1, las = 0)#
    mtext(paste(sep="", data[[1]]$type[1], " (", data[[1]]$unit[1], ")"),#
          1, line = 2, las = 0)#
#
#    draw_legend(legend_names, legend_col, legend_lty, legend_pch)#
#    mtext(document_name, side = 3, line = 2, cex = 2.2, las = 0)#
#
    rc <- dev.off()#
    data#
}#
#
`[.dataclass` <- function(x,i) {#
    class(x) <- "list"#
    structure(x[i], class="dataclass")#
}#
#
`>.dataclass` <- function(e1, e2) {#
    e1[[1]]$type[2] > e2[[1]]$type[2] ||#
    e1[[1]]$summary["3rd Qu."] > e2[[1]]$summary["3rd Qu."]#
}#
#
`==.dataclass` <- function(e1, e2) {#
    e1[[1]]$type[2] == e2[[1]]$type[2] &&#
    e1[[1]]$summary["3rd Qu."] == e2[[1]]$summary["3rd Qu."]#
}#
#
draw_summary <- function(data) {#
    print("Draw summary")#
    class(data) <- "dataclass"#
    data <- sort(data)#
    type <- data[[1]]$type[2]#
    flag_palette <<- "#0000FF"#
#
    # ecdf summaries#
    open_device(paste(names(data[[1]]$data)[2], "-ecdf-summary", sep=""), flag_output_type)#
    for (dat in data) {#
        if (type != dat$type[2]) {#
                type <- dat$type[2]#
                dev.off()#
            open_device(paste(names(dat$data)[2], "-ecdf-summary", sep=""), flag_output_type)#
            plotdat <- new_page(force_separated = TRUE)#
        }#
        plotdat <- reset_plotdat()#
        plotdat <- draw_ecdf(dat, plotdat, FALSE)#
        mtext(dat$name, side = 3, line = 0, cex = 1, las = 0)#
    }#
    dev.off()#
#
    # standard summaries#
    open_device(paste(names(data[[1]]$data)[2], "-std-summary", sep=""), flag_output_type)#
    for (dat in data) {#
        if (type != dat$type[2]) {#
                type <- dat$type[2]#
                dev.off()#
            open_device(paste(names(dat$data)[2], "-std-summary", sep=""), flag_output_type)#
            plotdat <- new_page(force_separated = TRUE)#
        }#
        plotdat <- reset_plotdat()#
        plotdat <- draw_normal(dat, plotdat, FALSE)#
        mtext(dat$name, side = 3, line = 0, cex = 1, las = 0)#
    }#
    dev.off()#
}
maxrtt
flag_maxrtt
flag_maxrtt <- 500
flag_maxtime <- 300
data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }
csvFiles <- list.files(".", pattern="^(ping[.]csv|iperf)$", recursive=FALSE)
csvFiles
data <- list()#
    min_t0 <- Inf#
    tmax <- 0#
    max_throughput <- 0#
    curve_num <- 0#
    for (f in csvFiles) {#
        print(paste("Computing data:", f))#
        data <- c(data, compute_data(f))#
    }#
#
    for (i in 1:length(data)) {#
        dat = data[[i]]#
        min_t0 = min(min_t0, dat$t0)#
        tmax = max(tmax, max(dat$data$time))#
        if (!is.na(dat$unit[2]) && dat$unit[2] == "bit/s") {#
            max_throughput <- max(max_throughput, dat$data$bitrate)#
        }#
        curve_num <- curve_num + (length(dat$type) - 1)#
        data[[i]] = rescale(dat)#
    }
data <- normalize(data, min_t0, tmax, max_throughput)
flag_palette <<- strsplit("#FF0000 #005500 #0000FF #000000", " ")[[1]]
plotdat <- new_page()#
#
    # Draw single plots#
    for (i in 1:length(data)) {#
        plotdat <- draw_ecdf(data[[i]], plotdat, FALSE)#
    }
x <- c(1)
x <- x[c(2:1), 1]
x <- x[c(2:1, 1)]
x
x <- x[c(2:1, 1)]
x
x <- x[c(2:1, 1)]
x
x <- x[c(2:1, 1)]
x
x[-1]
x
1 <- x
x <- 1
x
x[-1]
x
c(x[-1], x[1])
x <- 1
f <- function() {}
f <- function() { x <- 2; g()}
g <- function() { x }
g()
f()
ifelse(T, 1, 2)
ifelse(F, 1, 2)
ifelse(F, c(1,1), c(2,2))
rescale <- function(dat, time=flag_maxtime) {#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && flag_maxtime < Inf) {#
            dat$limit[i] = flag_maxtime#
            dat$data <- dat$data[dat$data$time <= flag_maxtime,]#
        } else if (dat$type[i] == "RTT" && flag_maxrtt < Inf) {#
            dat$limit[i] = flag_maxrtt#
        } else if (dat$type[i] == "Duplicates") {#
            # not implemented#
        } else if (dat$type[i] == "Hop number: 64-TTL") {#
            # not implemented#
        } else if (dat$type[i] == "Throughput") {#
            # not implemented#
        }#
    }#
    dat#
}
f <- function(x = 3)
x
f
f()
f(2)
f()
f <- function(x = y)
x
f()
y <- 1
f()
y <- 2
f()
rescale <- function(dat, time=flag_maxtime, rtt=flag_maxrtt, dup=Inf,#
                    hops=Inf, bitrate=Inf) {#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && time < Inf) {#
            dat$limit[i] = time#
            dat$data <- dat$data[dat$data$time <= time,]#
        } else if (dat$type[i] == "RTT" && rtt < Inf) {#
            dat$limit[i] = rtt#
        } else if (dat$type[i] == "Duplicates" && dup < Inf) {#
            dat$limit[i] = dup#
        } else if (dat$type[i] == "Hop number: 64-TTL" && hops < Inf) {#
            dat$limit[i] = hops#
        } else if (dat$type[i] == "Throughput" && bitrate < Inf) {#
            dat$limit[i] = bitrate#
        }#
    }#
    dat#
}
rescale <- function(dat, time=Inf, rtt=Inf, dup=Inf, hops=Inf, bitrate=Inf) {#
    if (flag_maxtime < Inf) time = flag_maxtime#
    if (flag_maxrtt < Inf) rtt = flag_maxrtt#
    for (i in 1:length(dat$type)) {#
        if (dat$type[i] == "Time" && time < Inf) {#
            dat$limit[i] = time#
            dat$data <- dat$data[dat$data$time <= time,]#
        } else if (dat$type[i] == "RTT" && rtt < Inf) {#
            dat$limit[i] = rtt#
        } else if (dat$type[i] == "Duplicates" && dup < Inf) {#
            dat$limit[i] = dup#
        } else if (dat$type[i] == "Hop number: 64-TTL" && hops < Inf) {#
            dat$limit[i] = hops#
        } else if (dat$type[i] == "Throughput" && bitrate < Inf) {#
            dat$limit[i] = bitrate#
        }#
    }#
    dat#
}
x = y = 3
x
y
y = 2
x
x <- y <- 3
x
y
2 <- y
y <- 2
x
y
dat
c(x=3)
x <- c(x=3,y=12)
x
y <- c(x=4,y=10)
y <- c(y=10,x=4)
y
x + y
min(x,y)
x
y
min(x,y)
x <- data.frame(x=c(), y=c())
x
x[1] = c(1,2)
x[1,] = c(1,2)
x[,1] = c(1,2)
x+ c(1,2)
x
x
names(x)
?min
pmin(c(1,2), c(2,1))
sapply(data)
data
?sapply
sapply(data, "[")
sapply(data, "[", "summary")
sapply(data, "[", summary)
x <- sapply(data, "[", "summary")
y <- sapply(data, "[", "types")
y
y <- sapply(data, "[", "type")
y
y <- sapply(data, "[", "type", "[", "2")
y <- sapply(data, "[", "type", "[")
y <- sapply(data, "[", "type", "[2]")
y <- sapply(data, "[", "type")
y
sapply(sapply(data, "[", "type"), "[")
sapply(sapply(data, "[", "type"), "[", "2")
sapply(sapply(data, "[", "type"), "[", "1")
sapply(sapply(data, "[", "type"), "[", "2,")
sapply(sapply(data, "[", "type"), "[", "2")
sapply(sapply(data, "[", "type"), "[2]")
sapply(sapply(data, "[", "type"), "[")
sapply(data, function(d){d$summary})
data
sapply(data, function(d){c(d$type[2], d$summary["Min."])})
sapply(data, function(d){c(name=d$type[2], min=d$summary["Min."])})
sapply(data, function(d){c(name=d$type[2], min=c(d$summary["Min."]))})
sapply(data, function(d){c(name=d$type[2], min=c(d$summary["Min."]))}, simplify=F)
dat
dat$summary["Min."]
?names
dat$summary["Min."]
dat$summary["Min."][0]
dat$summary["Min."][1]
dat$summary["Min."]$0
dat$summary["Min."]$1
dat$summary["Min."]
dat$summary["Min."] + 0
dat$summary["Min."] + 1
dat$summary["Min."]
sapply(data, function(d){c(name=d$type[2], min=c(d$summary["Min."]))}, simplify=F)
sapply(data, function(d){c(d$type[2])}, simplify=F)
sapply(data, function(d){c(d$type[2])})
sapply(data, function(d){c(names(d$data))})
names(dat$data)
sapply(data, function(d){c(names(d$data)[2])})
